/**
 * Enhanced Authentication Service
 * Integrates JWKS rotation, token binding, and Norwegian compliance automation
 * Enterprise Standards v4.0.0 compliant
 */

import { randomBytes } from "crypto";
import { Logger, EventCore } from "../foundation-mock.js"
import type {
  AuthenticationConfig,
  AuthenticationService,
  ServiceStatus,
  AuthenticationRequest,
  AuthenticationResult,
  SessionValidationResult,
  UserProfile,
  NSMClassification,
} from "../types/index.js";
import {
  isValidAuthenticationRequest,
  isValidUserProfile,
  safeGet,
} from "../utils/type-safety.js";
import {
  DefaultSessionManager,
  EnhancedTokenManager,
  SessionStorageFactory,
} from "../auth-core/index.js";
import type {
  SessionManager,
  SessionStorageBackend,
} from "../auth-core/types.js";
import { 
  DefaultProviderRegistry,
  ProviderFactory,
  type ProviderRegistry,
  type AuthenticationProvider 
} from "../auth-providers/index.js";
import { NorwegianComplianceAutomation } from "../utils/norwegian-compliance-automation.js";
import { DefaultComplianceService } from "../auth-compliance/compliance-service.js";
import type { ComplianceService } from "../auth-compliance/types.js";

interface EnhancedAuthenticationConfig extends AuthenticationConfig {
  readonly enhancedSecurity?: {
    readonly enableJWKSRotation?: boolean;
    readonly enableTokenBinding?: boolean;
    readonly keyRotationInterval?: number;
    readonly enableDeviceFingerprinting?: boolean;
  };
  readonly norwegianCompliance?: {
    readonly enableAutomaticClassification?: boolean;
    readonly enableGDPRAutomation?: boolean;
    readonly enableAuditTrail?: boolean;
    readonly auditIntervalDays?: number;
  };
  readonly enterprise?: {
    readonly enableComplianceAutomation?: boolean;
    readonly enableSecurityMetrics?: boolean;
    readonly enableThreatDetection?: boolean;
  };
}

interface DeviceInfo {
  readonly deviceId: string;
  readonly fingerprint: string;
  readonly platform: string;
  readonly userAgent?: string;
  readonly ipAddress?: string;
}

export class EnhancedAuthentication implements AuthenticationService {
  private config: EnhancedAuthenticationConfig;
  private logger: Logger;
  private events: EventCore;
  private sessionManager: SessionManager;
  private tokenManager: EnhancedTokenManager;
  private sessionStorage: SessionStorageBackend;
  private providerRegistry: ProviderRegistry;
  private providers: AuthenticationProvider[] = [];
  private complianceService: ComplianceService;
  private norwegianCompliance: NorwegianComplianceAutomation;
  private initialized = false;
  private activeSessions = 0;
  private totalLogins = 0;
  private securityMetrics = {
    failedAttempts: 0,
    suspiciousActivity: 0,
    complianceViolations: 0,
    deviceBindingViolations: 0
  };

  constructor(config: EnhancedAuthenticationConfig) {
    this.config = config;
    this.logger = Logger.create({
      serviceName: "enhanced-authentication",
      nsmClassification: config.nsmClassification,
      gdprCompliant: config.gdprCompliant,
      auditTrail: config.auditTrail,
    });
    this.events = EventCore.create({
      serviceName: "enhanced-authentication",
      nsmClassification: config.nsmClassification,
      gdprCompliant: config.gdprCompliant,
      auditTrail: config.auditTrail,
    });

    // Initialize storage
    this.sessionStorage = SessionStorageFactory.create(
      config.sessionStorage.type,
      this.logger,
    );

    // Initialize managers
    this.sessionManager = DefaultSessionManager.create(this.sessionStorage, {
      sessionTimeout: config.sessionTimeout,
      maxConcurrentSessions: config.maxConcurrentSessions,
      logger: this.logger,
      events: this.events,
    });

    this.tokenManager = EnhancedTokenManager.create({
      accessTokenSecret: this.generateSecret(),
      refreshTokenSecret: this.generateSecret(),
      accessTokenLifetime: config.accessTokenLifetime,
      refreshTokenLifetime: config.refreshTokenLifetime,
      issuer: "xala-authentication-enhanced",
      audience: "xala-application",
      logger: this.logger,
      jwksRotationEnabled: config.enhancedSecurity?.enableJWKSRotation ?? true,
      tokenBindingEnabled: config.enhancedSecurity?.enableTokenBinding ?? true,
      keyRotationInterval: config.enhancedSecurity?.keyRotationInterval ?? undefined,
    });

    // Initialize provider registry
    this.providerRegistry = DefaultProviderRegistry.create();

    // Initialize compliance services
    this.complianceService = DefaultComplianceService.create();
    
    this.norwegianCompliance = NorwegianComplianceAutomation.create(
      config.norwegianCompliance || {},
      this.logger
    );
  }

  async initialize(): Promise<void> {
    if (this.initialized) {
      return;
    }

    this.logger.info("Initializing enhanced authentication service", {
      nsmClassification: this.config.nsmClassification,
      gdprCompliant: this.config.gdprCompliant,
      providers: this.config.providers.map((p) => p.id),
      enhancedSecurity: {
        jwksRotation: this.config.enhancedSecurity?.enableJWKSRotation ?? true,
        tokenBinding: this.config.enhancedSecurity?.enableTokenBinding ?? true,
        deviceFingerprinting: this.config.enhancedSecurity?.enableDeviceFingerprinting ?? false
      }
    });

    // Initialize session storage
    await this.sessionStorage.initialize(this.config.sessionStorage);

    // Initialize providers
    this.providers = ProviderFactory.createProviders(this.config.providers);
    for (const provider of this.providers) {
      await provider.initialize();
      this.providerRegistry.register(provider);
      this.logger.info("Provider initialized", {
        providerId: provider.id,
        providerType: provider.type,
        enabled: provider.enabled,
      });
    }

    // Setup cleanup intervals
    this.setupCleanupTasks();

    // Setup compliance monitoring
    if (this.config.enterprise?.enableComplianceAutomation) {
      this.setupComplianceMonitoring();
    }

    this.initialized = true;

    this.logger.info("Enhanced authentication service initialized successfully");
  }

  async authenticate(
    request: AuthenticationRequest & { deviceInfo?: DeviceInfo },
  ): Promise<AuthenticationResult> {
    try {
      // Validate request using type safety utilities
      if (!isValidAuthenticationRequest(request)) {
        this.securityMetrics.failedAttempts++;
        return {
          success: false,
          error: {
            code: "INVALID_REQUEST",
            message: "Invalid authentication request format",
            nsmClassification: "OPEN",
          },
        };
      }

      // Enhanced threat detection
      if (this.config.enterprise?.enableThreatDetection) {
        const threatAssessment = await this.assessSecurityThreat(request);
        if (threatAssessment.risk === 'HIGH' || threatAssessment.risk === 'CRITICAL') {
          this.securityMetrics.suspiciousActivity++;
          this.logger.warn("High risk authentication attempt detected", {
            provider: request.provider,
            risk: threatAssessment.risk,
            reasons: threatAssessment.reasons
          });
          
          // Could implement additional verification here
        }
      }

      // Find provider
      const provider = this.providerRegistry.getProvider(request.provider);
      if (!provider || !provider.enabled) {
        this.securityMetrics.failedAttempts++;
        return {
          success: false,
          error: {
            code: "PROVIDER_NOT_FOUND",
            message: `Provider ${request.provider} not found or disabled`,
            nsmClassification: "OPEN",
          },
        };
      }

      // Authenticate using provider
      const providerResult = await provider.authenticate({
        type: provider.type,
        ...request.credentials
      });
      
      if (!providerResult.success || !providerResult.user) {
        this.securityMetrics.failedAttempts++;
        return {
          success: false,
          error: providerResult.error ?? {
            code: "AUTHENTICATION_FAILED",
            message: "Provider authentication failed",
            nsmClassification: "OPEN",
          },
        };
      }

      const user = providerResult.user;

      // Norwegian compliance processing for government providers
      if (['norwegian-id', 'bankid', 'buypass', 'commfides'].includes(request.provider)) {
        const complianceResult = await this.norwegianCompliance.processNorwegianAuthData({
          personalNumber: user.norwegianPersonalNumber,
          provider: request.provider as 'bankid' | 'buypass' | 'commfides',
          securityLevel: (user.metadata?.securityLevel as number) || 3,
          attributes: user.metadata || {}
        });

        // Update user classification based on compliance automation
        if (complianceResult.success) {
          user.nsmClassification = complianceResult.classification;
          
          // Schedule compliance actions if needed
          if (complianceResult.actions.length > 0) {
            await this.norwegianCompliance.scheduleAutomatedActions(
              `user-${user.id}`,
              [...complianceResult.actions]
            );
          }
        }
      }

      // Create session
      const session = await this.sessionManager.createSession(
        user,
        request.clientInfo,
        request.provider,
      );

      // Generate enhanced tokens with device binding if enabled
      const deviceInfo = request.deviceInfo;
      const accessToken = await this.tokenManager.generateAccessToken(
        user,
        session.id,
        deviceInfo
      );
      const refreshToken = await this.tokenManager.generateRefreshToken(
        user,
        session.id,
        deviceInfo
      );

      this.activeSessions++;
      this.totalLogins++;

      // Emit compliance event
      this.events.emit('authentication.success', {
        id: `auth-${session.id}`,
        type: 'authentication.success',
        source: 'enhanced-authentication',
        userId: user.id,
        provider: request.provider,
        sessionId: session.id,
        nsmClassification: user.nsmClassification,
        deviceBinding: !!deviceInfo,
        timestamp: new Date(),
        gdprProtected: true,
        auditTrail: true
      });

      this.logger.info("User authenticated successfully with enhanced security", {
        userId: user.id,
        provider: request.provider,
        sessionId: session.id,
        nsmClassification: user.nsmClassification,
        hasDeviceBinding: !!deviceInfo,
        securityLevel: (user.metadata?.securityLevel as number) || 3
      });

      return {
        success: true,
        accessToken,
        refreshToken,
        expiresIn: Math.floor(this.config.accessTokenLifetime / 1000),
        user,
        session,
      };
    } catch (error) {
      this.securityMetrics.failedAttempts++;
      this.logger.error("Enhanced authentication failed", {
        provider: request.provider,
        error: (error as Error).message,
        deviceInfo: request.deviceInfo ? 'present' : 'absent'
      });

      return {
        success: false,
        error: {
          code: "AUTHENTICATION_FAILED",
          message: "Authentication failed",
          nsmClassification: "OPEN",
        },
      };
    }
  }

  async refresh(
    refreshToken: string,
    deviceInfo?: DeviceInfo
  ): Promise<AuthenticationResult> {
    const result = await this.tokenManager.refreshAccessToken(refreshToken);

    if (result.success) {
      this.logger.debug("Enhanced token refreshed successfully", {
        hasDeviceInfo: !!deviceInfo
      });
      return {
        success: true,
        ...(result.accessToken && { accessToken: result.accessToken }),
        ...(result.expiresIn && { expiresIn: result.expiresIn }),
      };
    } else {
      this.logger.warn("Enhanced token refresh failed", {
        error: result.error ?? "Unknown error",
      });
      return {
        success: false,
        error: {
          code: "TOKEN_REFRESH_FAILED",
          message: result.error || "Token refresh failed",
          nsmClassification: "OPEN",
        },
      };
    }
  }

  async validateToken(
    token: string,
    deviceInfo?: DeviceInfo
  ): Promise<{ valid: boolean; claims?: any; error?: string }> {
    const result = await this.tokenManager.validateToken(token, deviceInfo);
    
    if (!result.valid && deviceInfo && result.error?.includes('device binding')) {
      this.securityMetrics.deviceBindingViolations++;
      this.logger.warn("Device binding validation failed", {
        deviceId: deviceInfo.deviceId,
        error: result.error
      });
    }

    return result;
  }

  async logout(sessionId: string): Promise<void> {
    await this.sessionManager.deleteSession(sessionId);
    this.activeSessions = Math.max(0, this.activeSessions - 1);

    this.logger.info("User logged out from enhanced session", { sessionId });
  }

  async validateSession(sessionId: string): Promise<SessionValidationResult> {
    const session = await this.sessionManager.getSession(sessionId);

    if (!session) {
      return {
        valid: false,
        error: "Session not found or expired",
      };
    }

    // Load user profile from session using type safety
    const userProfile = safeGet(session as unknown as Record<string, unknown>, "metadata.userProfile", null);
    const user: UserProfile = isValidUserProfile(userProfile)
      ? userProfile
      : {
          id: session.userId,
          roles: [],
          permissions: [],
          nsmClassification: session.nsmClassification,
          metadata: {},
        };

    return {
      valid: true,
      user,
      session,
    };
  }

  async getStatus(): Promise<ServiceStatus & {
    enhancedFeatures: {
      jwksRotation: boolean;
      tokenBinding: boolean;
      norwegianCompliance: boolean;
      complianceAutomation: boolean;
    };
    securityMetrics: typeof this.securityMetrics;
    jwks?: any;
  }> {
    const healthy = this.initialized && (await this.sessionStorage.health());
    const jwks = await this.tokenManager.getJWKS();

    return {
      healthy,
      version: "1.0.0-enhanced",
      uptime: process.uptime(),
      lastCheck: new Date(),
      activeProviders: this.config.providers
        .filter((p) => p.enabled)
        .map((p) => p.id),
      activeSessions: this.activeSessions,
      totalLogins: this.totalLogins,
      enhancedFeatures: {
        jwksRotation: this.config.enhancedSecurity?.enableJWKSRotation ?? true,
        tokenBinding: this.config.enhancedSecurity?.enableTokenBinding ?? true,
        norwegianCompliance: !!this.config.norwegianCompliance,
        complianceAutomation: this.config.enterprise?.enableComplianceAutomation ?? false
      },
      securityMetrics: this.securityMetrics,
      jwks
    };
  }

  /**
   * Get current JWKS endpoint for public key distribution
   */
  async getJWKS(): Promise<any> {
    return this.tokenManager.getJWKS();
  }

  /**
   * Force key rotation (for security incidents)
   */
  async rotateKeys(): Promise<void> {
    await this.tokenManager.rotateKeys();
    this.logger.info("Security keys rotated manually", {
      nsmClassification: 'RESTRICTED' as NSMClassification
    });
  }

  /**
   * Get compliance status
   */
  async getComplianceStatus(): Promise<any> {
    return this.complianceService.getComplianceStatus();
  }

  /**
   * Export compliance report
   */
  async exportComplianceReport(format: 'json' | 'html' | 'pdf'): Promise<Uint8Array> {
    return this.complianceService.exportComplianceReport(format);
  }

  private generateSecret(): string {
    return randomBytes(32).toString("hex");
  }

  private setupCleanupTasks(): void {
    // Setup session cleanup every 5 minutes
    setInterval(
      async () => {
        try {
          await this.sessionManager.cleanupExpiredSessions();
        } catch (error) {
          this.logger.error("Session cleanup failed", {
            error: (error as Error).message,
          });
        }
      },
      5 * 60 * 1000,
    );
  }

  private setupComplianceMonitoring(): void {
    // Schedule compliance audits every hour
    setInterval(async () => {
      try {
        if (this.totalLogins > 0) {
          const auditRequest = await this.norwegianCompliance.generateComplianceAudit(
            'enhanced-authentication',
            ['authentication', 'session', 'token'],
            'RESTRICTED'
          );
          
          const auditResult = await this.complianceService.performAudit(auditRequest);
          
          if (!auditResult.overallCompliant) {
            this.securityMetrics.complianceViolations++;
            this.logger.warn("Compliance audit failed", {
              auditId: auditResult.id,
              recommendations: auditResult.recommendations.length
            });
          }
        }
      } catch (error) {
        this.logger.error("Compliance monitoring failed", {
          error: (error as Error).message
        });
      }
    }, 60 * 60 * 1000); // Every hour
  }

  private async assessSecurityThreat(
    request: AuthenticationRequest & { deviceInfo?: DeviceInfo }
  ): Promise<{ risk: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'; reasons: string[] }> {
    const reasons: string[] = [];
    let riskScore = 0;

    // Check for unusual provider patterns
    if (this.securityMetrics.failedAttempts > 10) {
      riskScore += 2;
      reasons.push('High failed attempt rate');
    }

    // Check device consistency
    if (request.deviceInfo && !request.deviceInfo.deviceId) {
      riskScore += 1;
      reasons.push('Missing device identification');
    }

    // Check provider risk
    if (!['bankid', 'buypass', 'commfides'].includes(request.provider)) {
      riskScore += 1;
      reasons.push('Non-government authentication provider');
    }

    // Determine risk level
    let risk: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
    if (riskScore >= 4) {
      risk = 'CRITICAL';
    } else if (riskScore >= 3) {
      risk = 'HIGH';
    } else if (riskScore >= 2) {
      risk = 'MEDIUM';
    } else {
      risk = 'LOW';
    }

    return { risk, reasons };
  }

  static create(config: EnhancedAuthenticationConfig): EnhancedAuthentication {
    return new EnhancedAuthentication(config);
  }
}